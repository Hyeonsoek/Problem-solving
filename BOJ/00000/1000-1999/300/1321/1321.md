# 문제 풀이
## 요구 조건
1. $1\;i\;a$ : List의 $i$의 값을 $a$만큼 변경
2. $2\;i$ : $i$번째 값이 존재하는 index 출력
3. $N\leq500,000\;,M\leq10,000$

## 생각 과정
1. 1번 Query는 List의 값만 변경하는 방식으로 $O(1)$,
    2번 Query는 List 값을 하나씩 확인하며 그룹 번호를 찾는 방법으로 $O(N)$,
    전체 명령 횟수 $M$이므로 최대 $O(NM)$으로 구할 수 있음.
2. 3번 조건에 의해서, $O(MN)$ 방법으로는 시간 제한에 걸려 통과할 수 없음.
3. 2번 Query의 방법을 바꿔서, ${\sum_{n=1}^{j}arr[n]}\leq{i}$ 를 만족하는 j를 구하는 방법은?
4. 단순 구간 합으로는 1번 Query 처리에 $O(N)$ 이 걸려버림(이전과 같은 결과가 나와버린다)
5. 갱신과 구간 합을 동시에 빠르게 구해야하는데, Segment Tree를 사용하면 좋을 것 같다.
6. 1번 Query는 합을 저장하는 Segment Tree의 Update를 구현
7. 2번 Query는 왼쪽 자식의 값보다 현재 비교하려는 값이 작거나 같다면, 왼쪽 sub tree에서 탐색하고,
    아니라면 왼쪽 자식 값만큼 뺀 값을 오른쪽 sub tree에서 탐색하면된다.
8. 두 Query 모두다 $O(\log(N))$ 이므로, $O(M\log(N))$ 에 해결될듯