# 문제
- 규칙에 따라서 문자열을 만들었을 때, $N$번째 문자열의 $N$번째 문자를 구하는 문제

- $1\leq{N}\leq{10^9}$


# 풀이
- 풀이 시작 전에 다음과 같이 정의를 먼저하겠음.

    - $T(k)=$ "m" + "o" $\times {(k+3)}$

    - $S(k)=S(k-1)+T(k)+S(k-1)$

    - $S(0)=$ "moo"

- 일단 직접적으로 $S(k)$를 구현해서 $N$번째 문자를 찾는 방식은 절대 불가능하다. 그 이유는 다음과 같다.

    - $S(k)=S(k-1)+T(k)+S(k-1)$ 을 이용해서 길이에 대한 식으로 나타내면,

        - ${a_{n}}={2a_{n-1} + n + 3}$

    - $N$의 최대값은 $10^9$이다. 따라서 $a_n$에 대한 식을 대충보고 마지막 항의 길이를 유추해보면 $2^{10^9}$같은 정신 아득해지는 길이를 볼  수 있고, 메모리 초과와 시간 초과의 이유가 된다.

        - 128MB는 1억글자 밖에 안되기 때문에 메모리 초과

        - 또한, $10^9$은 10억이라서 결국 시간 초과

- 아이디어는 **"문자열의 길이가 $N$ 이상인 $k$만 구하면 된다는 것"** 이다.

    - $S(N)$ 을 분해하면서, 아래로 내려갔을 경우에, 반드시 $S(k)$ 를 구하게 됨.

        - $S(N)=S(N-1)+T(N)+S(N-1)$</br></br>
        $=S(N-2)+T(N-1)+S(N-2)+T(N)+S(N-2)+T(N-1)+S(N-2)$</br></br>
        $=...=S(k)+T(k+1)+S(k)+...+T(N)+...+S(k)+T(k+1)+S(k)$

    - 위 식에 따라서, 맨 앞의 $S(k)$만 구해서, 정답을 구할 수 있음을 알 수 있음.

    - 하지만 이렇게 구할 수 있어도 직접적으로 문자열을 구현하면 메모리 초과다. 

    - 그래서, $S(k)$ 까지의 각 단계별 길이와 주어진 $N$을 이용해서 구해야한다.
    
        - 현재 구하고자 하는 문자의 위치가 현재 단계 $k$에서 왼쪽, 중앙, 오른쪽 중에서 어디에 있는 지를 확인한다.

        - 중앙에 있다면 $T(k)$ 의 정의에 의해서 바로 구할 수 있다.

        - 왼쪽에 있다면, 이전 단계로 넘어간다.

        - 오른쪽에 있다면, 왼쪽과 중앙을 건너뛴것이다. 현재 위치에서 $a_{n-1} + n + 3$ (왼쪽 길이 + 중앙 길이)만큼을 빼준 새로운 위치를 오른쪽 $S(k-1)$ 에서 찾는다고 생각하면 된다. </br> 그리고 이전 단계로 넘어간다.

- 맞을 지는 모르겠는데 시간복잡도는 아마도 $O(\log{N})$ 이 되지 않을까 싶음. 왜냐하면, 문자열의 길이가 2배씩 늘어나기 때문에?

    - 실제로 실행했을 때도, 코드내의 <code>nn</code> 값이 2X였는데 정확하게 기억안나는...

    - 실행 결과는 32ms