# 문제
- 문제를 더 쉽게 설명하면,
    - 앞쪽에서부터 $K$개를 뒤집을 수 있다.
    - 뒤집을 때마다 부호가 바뀜.
    - 배열 내의 숫자가 앞에서부터 $1$~$N$이도록 뒤집기 연산을 했을때, 뒤집은 횟수와 $K$들을 출력

<br>

# 풀이
- Algorithm : Greedy
- 배열의 마지막 값을 먼저 만드는 방식으로 하였다. 규칙은
    - 현재 뒤쪽에 배치하려는 값이 배열의 마지막에 있고 양수인 경우, 배열에서 해당 값은 더 이상 계산이 불필요하기 때문에 삭제한다.
    - 현재 구하려는 값이 배열의 첫번째에 있고, 음수인 경우, 전체를 뒤집어 뒤로 보내준다. (1번이랑 합쳐도 될듯)
    - 나머지 경우에서는 배열을 앞쪽에서부터 탐색하면서, 음양 관계없이 뒤집어준다.
- 핵심은 이 방법대로 하면 어떻게해도 $3N-2$번을 초과할 수 없다는 것.
    - 왜냐하면 어디에 있든 3번만에 원하는 값을 위치시킬 수 있음
    - 마지막 값은 1인데 부호 결정을 위해서 최대 1번만 사용하면된다.
    - 따라서 $3N-2$번안에 반드시 정답에 도달함.